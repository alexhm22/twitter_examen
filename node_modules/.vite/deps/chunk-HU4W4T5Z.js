import {
  KeyboardDirectionMixin
} from "./chunk-E2TMSNCK.js";
import {
  DirHelper
} from "./chunk-RTIK5DCO.js";
import {
  Debouncer
} from "./chunk-VUWTYCVF.js";
import {
  timeOut
} from "./chunk-CQH3N2QY.js";
import {
  FlattenedNodesObserver
} from "./chunk-LQ5QREVC.js";

// node_modules/@vaadin/vaadin-list-mixin/vaadin-list-mixin.js
var ListMixin = (superClass) => class ListMixinClass extends KeyboardDirectionMixin(superClass) {
  static get properties() {
    return {
      _hasVaadinListMixin: {
        value: true
      },
      selected: {
        type: Number,
        reflectToAttribute: true,
        notify: true
      },
      orientation: {
        type: String,
        reflectToAttribute: true,
        value: ""
      },
      items: {
        type: Array,
        readOnly: true,
        notify: true
      },
      _searchBuf: {
        type: String,
        value: ""
      }
    };
  }
  static get observers() {
    return ["_enhanceItems(items, orientation, selected, disabled)"];
  }
  ready() {
    super.ready();
    this.addEventListener("click", (e) => this._onClick(e));
    this._observer = new FlattenedNodesObserver(this, () => {
      this._setItems(this._filterItems(FlattenedNodesObserver.getFlattenedNodes(this)));
    });
  }
  _getItems() {
    return this.items;
  }
  _enhanceItems(items, orientation, selected, disabled) {
    if (!disabled) {
      if (items) {
        this.setAttribute("aria-orientation", orientation || "vertical");
        this.items.forEach((item) => {
          if (orientation) {
            item.setAttribute("orientation", orientation);
          } else {
            item.removeAttribute("orientation");
          }
        });
        this._setFocusable(selected || 0);
        const itemToSelect = items[selected];
        items.forEach((item) => {
          item.selected = item === itemToSelect;
        });
        if (itemToSelect && !itemToSelect.disabled) {
          this._scrollToItem(selected);
        }
      }
    }
  }
  _filterItems(array) {
    return array.filter((e) => e._hasVaadinItemMixin);
  }
  _onClick(event) {
    if (event.metaKey || event.shiftKey || event.ctrlKey || event.defaultPrevented) {
      return;
    }
    const item = this._filterItems(event.composedPath())[0];
    let idx;
    if (item && !item.disabled && (idx = this.items.indexOf(item)) >= 0) {
      this.selected = idx;
    }
  }
  _searchKey(currentIdx, key) {
    this._searchReset = Debouncer.debounce(this._searchReset, timeOut.after(500), () => {
      this._searchBuf = "";
    });
    this._searchBuf += key.toLowerCase();
    if (!this.items.some((item) => this.__isMatchingKey(item))) {
      this._searchBuf = key.toLowerCase();
    }
    const idx = this._searchBuf.length === 1 ? currentIdx + 1 : currentIdx;
    return this._getAvailableIndex(
      this.items,
      idx,
      1,
      (item) => this.__isMatchingKey(item) && getComputedStyle(item).display !== "none"
    );
  }
  __isMatchingKey(item) {
    return item.textContent.replace(/[^\p{L}\p{Nd}]/gu, "").toLowerCase().startsWith(this._searchBuf);
  }
  get _isRTL() {
    return !this._vertical && this.getAttribute("dir") === "rtl";
  }
  _onKeyDown(event) {
    if (event.metaKey || event.ctrlKey) {
      return;
    }
    const key = event.key;
    const currentIdx = this.items.indexOf(this.focused);
    if (/[a-zA-Z0-9]/.test(key) && key.length === 1) {
      const idx = this._searchKey(currentIdx, key);
      if (idx >= 0) {
        this._focus(idx);
      }
      return;
    }
    super._onKeyDown(event);
  }
  _isItemHidden(item) {
    return getComputedStyle(item).display === "none";
  }
  _setFocusable(idx) {
    idx = this._getAvailableIndex(this.items, idx, 1);
    const item = this.items[idx];
    this.items.forEach((e) => {
      e.tabIndex = e === item ? 0 : -1;
    });
  }
  _focus(idx) {
    this.items.forEach((e, index) => {
      e.focused = index === idx;
    });
    this._setFocusable(idx);
    this._scrollToItem(idx);
    super._focus(idx);
  }
  focus() {
    if (this._observer) {
      this._observer.flush();
    }
    const firstItem = this.querySelector('[tabindex="0"]') || (this.items ? this.items[0] : null);
    this._focusItem(firstItem);
  }
  get _scrollerElement() {
    console.warn(`Please implement the '_scrollerElement' property in <${this.localName}>`);
    return this;
  }
  _scrollToItem(idx) {
    const item = this.items[idx];
    if (!item) {
      return;
    }
    const props = this._vertical ? ["top", "bottom"] : this._isRTL ? ["right", "left"] : ["left", "right"];
    const scrollerRect = this._scrollerElement.getBoundingClientRect();
    const nextItemRect = (this.items[idx + 1] || item).getBoundingClientRect();
    const prevItemRect = (this.items[idx - 1] || item).getBoundingClientRect();
    let scrollDistance = 0;
    if (!this._isRTL && nextItemRect[props[1]] >= scrollerRect[props[1]] || this._isRTL && nextItemRect[props[1]] <= scrollerRect[props[1]]) {
      scrollDistance = nextItemRect[props[1]] - scrollerRect[props[1]];
    } else if (!this._isRTL && prevItemRect[props[0]] <= scrollerRect[props[0]] || this._isRTL && prevItemRect[props[0]] >= scrollerRect[props[0]]) {
      scrollDistance = prevItemRect[props[0]] - scrollerRect[props[0]];
    }
    this._scroll(scrollDistance);
  }
  get _vertical() {
    return this.orientation !== "horizontal";
  }
  _scroll(pixels) {
    if (this._vertical) {
      this._scrollerElement.scrollTop += pixels;
    } else {
      const dir = this.getAttribute("dir") || "ltr";
      const scrollType = DirHelper.detectScrollType();
      const scrollLeft = DirHelper.getNormalizedScrollLeft(scrollType, dir, this._scrollerElement) + pixels;
      DirHelper.setNormalizedScrollLeft(scrollType, dir, this._scrollerElement, scrollLeft);
    }
  }
};

export {
  ListMixin
};
/**
 * @license
 * Copyright (c) 2017 - 2022 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
//# sourceMappingURL=chunk-HU4W4T5Z.js.map
