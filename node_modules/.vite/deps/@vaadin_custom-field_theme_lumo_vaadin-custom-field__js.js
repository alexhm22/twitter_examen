import "./chunk-KWBG2NLZ.js";
import {
  FieldMixin
} from "./chunk-NUPKK76C.js";
import "./chunk-CSTDY47U.js";
import "./chunk-L55YM4J4.js";
import {
  KeyboardMixin
} from "./chunk-Q67J475U.js";
import {
  FocusMixin
} from "./chunk-LJ4MV4IY.js";
import "./chunk-VJGDHWCK.js";
import {
  TooltipController
} from "./chunk-L374UGML.js";
import "./chunk-F4BRGDFL.js";
import "./chunk-26L5GZ27.js";
import "./chunk-GA4D3JZK.js";
import {
  ElementMixin
} from "./chunk-35PYPRLR.js";
import "./chunk-WB77GQTL.js";
import "./chunk-LSFWBQOV.js";
import "./chunk-UMO66KPY.js";
import "./chunk-EF42WAVP.js";
import "./chunk-OFT7WUTJ.js";
import "./chunk-YELGMEWD.js";
import {
  ThemableMixin
} from "./chunk-VCK5WHZR.js";
import "./chunk-RTIK5DCO.js";
import "./chunk-VUWTYCVF.js";
import "./chunk-KW5WBOXY.js";
import "./chunk-L65BUNLZ.js";
import "./chunk-CQH3N2QY.js";
import {
  FlattenedNodesObserver
} from "./chunk-LQ5QREVC.js";
import {
  PolymerElement
} from "./chunk-BK2NTPF4.js";
import "./chunk-A5QYNKPK.js";
import "./chunk-ZNZEAP57.js";
import "./chunk-54PPSA5Z.js";
import {
  html
} from "./chunk-BPZOCPE6.js";
import "./chunk-CJPRR7ZF.js";

// node_modules/@vaadin/custom-field/src/vaadin-custom-field.js
var CustomField = class extends FieldMixin(FocusMixin(KeyboardMixin(ThemableMixin(ElementMixin(PolymerElement))))) {
  static get is() {
    return "vaadin-custom-field";
  }
  static get template() {
    return html`
      <style>
        :host {
          display: inline-flex;
        }

        :host::before {
          content: '\\2003';
          width: 0;
          display: inline-block;
          /* Size and position this element on the same vertical position as the input-field element
           to make vertical align for the host element work as expected */
        }

        :host([hidden]) {
          display: none !important;
        }

        .vaadin-custom-field-container {
          width: 100%;
          display: flex;
          flex-direction: column;
        }

        .inputs-wrapper {
          flex: none;
        }
      </style>

      <div class="vaadin-custom-field-container">
        <div part="label" on-click="focus">
          <slot name="label"></slot>
          <span part="required-indicator" aria-hidden="true"></span>
        </div>

        <div class="inputs-wrapper" on-change="__onInputChange">
          <slot id="slot"></slot>
        </div>

        <div part="helper-text">
          <slot name="helper"></slot>
        </div>

        <div part="error-message">
          <slot name="error-message"></slot>
        </div>
      </div>

      <slot name="tooltip"></slot>
    `;
  }
  static get properties() {
    return {
      name: String,
      value: {
        type: String,
        observer: "__valueChanged",
        notify: true
      },
      inputs: {
        type: Array,
        readOnly: true
      },
      formatValue: {
        type: Function
      },
      parseValue: {
        type: Function
      },
      i18n: {
        type: Object,
        value: () => {
          return {
            parseValue(value) {
              return value.split("	");
            },
            formatValue(inputValues) {
              return inputValues.join("	");
            }
          };
        }
      }
    };
  }
  connectedCallback() {
    super.connectedCallback();
    if (this.__observer) {
      this.__observer.connect();
    }
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    if (this.__observer) {
      this.__observer.disconnect();
    }
  }
  ready() {
    super.ready();
    this.setAttribute("role", "group");
    this.ariaTarget = this;
    this.__setInputsFromSlot();
    this.__observer = new FlattenedNodesObserver(this.$.slot, () => {
      this.__setInputsFromSlot();
    });
    this._tooltipController = new TooltipController(this);
    this.addController(this._tooltipController);
    this._tooltipController.setShouldShow((target) => {
      const inputs = target.inputs || [];
      return !inputs.some((el) => el.opened);
    });
  }
  focus() {
    if (this.inputs && this.inputs[0]) {
      this.inputs[0].focus();
    }
  }
  _setFocused(focused) {
    super._setFocused(focused);
    if (!focused) {
      this.validate();
    }
  }
  _shouldRemoveFocus(event) {
    const { relatedTarget } = event;
    return !this.inputs.some((el) => relatedTarget === (el.focusElement || el));
  }
  checkValidity() {
    const invalidFields = this.inputs.filter((input) => !(input.validate || input.checkValidity).call(input));
    if (invalidFields.length || this.required && !this.value.trim()) {
      return false;
    }
    return true;
  }
  _onKeyDown(e) {
    if (e.key === "Tab") {
      if (this.inputs.indexOf(e.target) < this.inputs.length - 1 && !e.shiftKey || this.inputs.indexOf(e.target) > 0 && e.shiftKey) {
        this.dispatchEvent(new CustomEvent("internal-tab"));
      } else {
        this.__setValue();
      }
    }
  }
  __onInputChange(event) {
    event.stopPropagation();
    this.__setValue();
    this.validate();
    this.dispatchEvent(
      new CustomEvent("change", {
        bubbles: true,
        cancelable: false,
        detail: {
          value: this.value
        }
      })
    );
  }
  __setValue() {
    this.__settingValue = true;
    const formatFn = this.formatValue || this.i18n.formatValue;
    this.value = formatFn.apply(this, [this.inputs.map((input) => input.value)]);
    this.__settingValue = false;
  }
  __queryAllAssignedElements(elem) {
    const result = [];
    let elements;
    if (elem.tagName === "SLOT") {
      elements = elem.assignedElements({ flatten: true });
    } else {
      result.push(elem);
      elements = Array.from(elem.children);
    }
    elements.forEach((elem2) => result.push(...this.__queryAllAssignedElements(elem2)));
    return result;
  }
  __isInput(node) {
    const isSlottedInput = node.getAttribute("slot") === "input" || node.getAttribute("slot") === "textarea";
    return !isSlottedInput && (node.validate || node.checkValidity);
  }
  __getInputsFromSlot() {
    return this.__queryAllAssignedElements(this.$.slot).filter((node) => this.__isInput(node));
  }
  __setInputsFromSlot() {
    this._setInputs(this.__getInputsFromSlot());
    this.__setValue();
  }
  __toggleHasValue(value) {
    this.toggleAttribute("has-value", value !== null && value.trim() !== "");
  }
  __valueChanged(value, oldValue) {
    if (this.__settingValue || !this.inputs) {
      return;
    }
    this.__toggleHasValue(value);
    const parseFn = this.parseValue || this.i18n.parseValue;
    const valuesArray = parseFn.apply(this, [value]);
    if (!valuesArray || valuesArray.length === 0) {
      console.warn("Value parser has not provided values array");
      return;
    }
    this.inputs.forEach((input, id) => {
      input.value = valuesArray[id];
    });
    if (oldValue !== void 0) {
      this.validate();
    }
  }
};
customElements.define(CustomField.is, CustomField);
/**
 * @license
 * Copyright (c) 2019 - 2022 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
//# sourceMappingURL=@vaadin_custom-field_theme_lumo_vaadin-custom-field__js.js.map
