{
  "version": 3,
  "sources": ["../../@vaadin/overlay/src/vaadin-overlay-position-mixin.js"],
  "sourcesContent": ["/**\n * @license\n * Copyright (c) 2017 - 2022 Vaadin Ltd.\n * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n */\nimport { getAncestorRootNodes } from '@vaadin/component-base/src/dom-utils.js';\n\nconst PROP_NAMES_VERTICAL = {\n  start: 'top',\n  end: 'bottom',\n};\n\nconst PROP_NAMES_HORIZONTAL = {\n  start: 'left',\n  end: 'right',\n};\n\nconst targetResizeObserver = new ResizeObserver((entries) => {\n  setTimeout(() => {\n    entries.forEach((entry) => {\n      if (entry.target.__overlay) {\n        entry.target.__overlay._updatePosition();\n      }\n    });\n  });\n});\n\n/**\n * @polymerMixin\n */\nexport const PositionMixin = (superClass) =>\n  class PositionMixin extends superClass {\n    static get properties() {\n      return {\n        /**\n         * The element next to which this overlay should be aligned.\n         * The position of the overlay relative to the positionTarget can be adjusted\n         * with properties `horizontalAlign`, `verticalAlign`, `noHorizontalOverlap`\n         * and `noVerticalOverlap`.\n         */\n        positionTarget: {\n          type: Object,\n          value: null,\n        },\n\n        /**\n         * When `positionTarget` is set, this property defines whether to align the overlay's\n         * left or right side to the target element by default.\n         * Possible values are `start` and `end`.\n         * RTL is taken into account when interpreting the value.\n         * The overlay is automatically flipped to the opposite side when it doesn't fit into\n         * the default side defined by this property.\n         *\n         * @attr {start|end} horizontal-align\n         */\n        horizontalAlign: {\n          type: String,\n          value: 'start',\n        },\n\n        /**\n         * When `positionTarget` is set, this property defines whether to align the overlay's\n         * top or bottom side to the target element by default.\n         * Possible values are `top` and `bottom`.\n         * The overlay is automatically flipped to the opposite side when it doesn't fit into\n         * the default side defined by this property.\n         *\n         * @attr {top|bottom} vertical-align\n         */\n        verticalAlign: {\n          type: String,\n          value: 'top',\n        },\n\n        /**\n         * When `positionTarget` is set, this property defines whether the overlay should overlap\n         * the target element in the x-axis, or be positioned right next to it.\n         *\n         * @attr {boolean} no-horizontal-overlap\n         */\n        noHorizontalOverlap: {\n          type: Boolean,\n          value: false,\n        },\n\n        /**\n         * When `positionTarget` is set, this property defines whether the overlay should overlap\n         * the target element in the y-axis, or be positioned right above/below it.\n         *\n         * @attr {boolean} no-vertical-overlap\n         */\n        noVerticalOverlap: {\n          type: Boolean,\n          value: false,\n        },\n      };\n    }\n\n    static get observers() {\n      return [\n        '__positionSettingsChanged(horizontalAlign, verticalAlign, noHorizontalOverlap, noVerticalOverlap)',\n        '__overlayOpenedChanged(opened, positionTarget)',\n      ];\n    }\n\n    constructor() {\n      super();\n\n      this.__onScroll = this.__onScroll.bind(this);\n      this._updatePosition = this._updatePosition.bind(this);\n    }\n\n    /** @protected */\n    connectedCallback() {\n      super.connectedCallback();\n\n      if (this.opened) {\n        this.__addUpdatePositionEventListeners();\n      }\n    }\n\n    /** @protected */\n    disconnectedCallback() {\n      super.disconnectedCallback();\n      this.__removeUpdatePositionEventListeners();\n    }\n\n    /** @private */\n    __addUpdatePositionEventListeners() {\n      window.addEventListener('resize', this._updatePosition);\n\n      this.__positionTargetAncestorRootNodes = getAncestorRootNodes(this.positionTarget);\n      this.__positionTargetAncestorRootNodes.forEach((node) => {\n        node.addEventListener('scroll', this.__onScroll, true);\n      });\n    }\n\n    /** @private */\n    __removeUpdatePositionEventListeners() {\n      window.removeEventListener('resize', this._updatePosition);\n\n      if (this.__positionTargetAncestorRootNodes) {\n        this.__positionTargetAncestorRootNodes.forEach((node) => {\n          node.removeEventListener('scroll', this.__onScroll, true);\n        });\n        this.__positionTargetAncestorRootNodes = null;\n      }\n    }\n\n    /** @private */\n    __overlayOpenedChanged(opened, positionTarget) {\n      this.__removeUpdatePositionEventListeners();\n\n      if (positionTarget) {\n        positionTarget.__overlay = null;\n        targetResizeObserver.unobserve(positionTarget);\n\n        if (opened) {\n          this.__addUpdatePositionEventListeners();\n          positionTarget.__overlay = this;\n          targetResizeObserver.observe(positionTarget);\n        }\n      }\n\n      if (opened) {\n        const computedStyle = getComputedStyle(this);\n        if (!this.__margins) {\n          this.__margins = {};\n          ['top', 'bottom', 'left', 'right'].forEach((propName) => {\n            this.__margins[propName] = parseInt(computedStyle[propName], 10);\n          });\n        }\n        this.setAttribute('dir', computedStyle.direction);\n\n        this._updatePosition();\n        // Schedule another position update (to cover virtual keyboard opening for example)\n        requestAnimationFrame(() => this._updatePosition());\n      }\n    }\n\n    get __isRTL() {\n      return this.getAttribute('dir') === 'rtl';\n    }\n\n    __positionSettingsChanged() {\n      this._updatePosition();\n    }\n\n    /** @private */\n    __onScroll(e) {\n      // If the scroll event occurred inside the overlay, ignore it.\n      if (!this.contains(e.target)) {\n        this._updatePosition();\n      }\n    }\n\n    _updatePosition() {\n      if (!this.positionTarget || !this.opened) {\n        return;\n      }\n\n      const targetRect = this.positionTarget.getBoundingClientRect();\n\n      // Detect the desired alignment and update the layout accordingly\n      const shouldAlignStartVertically = this.__shouldAlignStartVertically(targetRect);\n      this.style.justifyContent = shouldAlignStartVertically ? 'flex-start' : 'flex-end';\n\n      const shouldAlignStartHorizontally = this.__shouldAlignStartHorizontally(targetRect, this.__isRTL);\n      const flexStart =\n        (!this.__isRTL && shouldAlignStartHorizontally) || (this.__isRTL && !shouldAlignStartHorizontally);\n      this.style.alignItems = flexStart ? 'flex-start' : 'flex-end';\n\n      // Get the overlay rect after possible overlay alignment changes\n      const overlayRect = this.getBoundingClientRect();\n\n      // Obtain vertical positioning properties\n      const verticalProps = this.__calculatePositionInOneDimension(\n        targetRect,\n        overlayRect,\n        this.noVerticalOverlap,\n        PROP_NAMES_VERTICAL,\n        this,\n        shouldAlignStartVertically,\n      );\n\n      // Obtain horizontal positioning properties\n      const horizontalProps = this.__calculatePositionInOneDimension(\n        targetRect,\n        overlayRect,\n        this.noHorizontalOverlap,\n        PROP_NAMES_HORIZONTAL,\n        this,\n        shouldAlignStartHorizontally,\n      );\n\n      // Apply the positioning properties to the overlay\n      Object.assign(this.style, verticalProps, horizontalProps);\n\n      this.toggleAttribute('bottom-aligned', !shouldAlignStartVertically);\n      this.toggleAttribute('top-aligned', shouldAlignStartVertically);\n\n      this.toggleAttribute('end-aligned', !flexStart);\n      this.toggleAttribute('start-aligned', flexStart);\n    }\n\n    __shouldAlignStartHorizontally(targetRect, rtl) {\n      // Using previous size to fix a case where window resize may cause the overlay to be squeezed\n      // smaller than its current space before the fit-calculations.\n      const contentWidth = Math.max(this.__oldContentWidth || 0, this.$.overlay.offsetWidth);\n      this.__oldContentWidth = this.$.overlay.offsetWidth;\n\n      const viewportWidth = Math.min(window.innerWidth, document.documentElement.clientWidth);\n      const defaultAlignLeft = (!rtl && this.horizontalAlign === 'start') || (rtl && this.horizontalAlign === 'end');\n\n      return this.__shouldAlignStart(\n        targetRect,\n        contentWidth,\n        viewportWidth,\n        this.__margins,\n        defaultAlignLeft,\n        this.noHorizontalOverlap,\n        PROP_NAMES_HORIZONTAL,\n      );\n    }\n\n    __shouldAlignStartVertically(targetRect) {\n      // Using previous size to fix a case where window resize may cause the overlay to be squeezed\n      // smaller than its current space before the fit-calculations.\n      const contentHeight = Math.max(this.__oldContentHeight || 0, this.$.overlay.offsetHeight);\n      this.__oldContentHeight = this.$.overlay.offsetHeight;\n\n      const viewportHeight = Math.min(window.innerHeight, document.documentElement.clientHeight);\n      const defaultAlignTop = this.verticalAlign === 'top';\n\n      return this.__shouldAlignStart(\n        targetRect,\n        contentHeight,\n        viewportHeight,\n        this.__margins,\n        defaultAlignTop,\n        this.noVerticalOverlap,\n        PROP_NAMES_VERTICAL,\n      );\n    }\n\n    // eslint-disable-next-line max-params\n    __shouldAlignStart(targetRect, contentSize, viewportSize, margins, defaultAlignStart, noOverlap, propNames) {\n      const spaceForStartAlignment =\n        viewportSize - targetRect[noOverlap ? propNames.end : propNames.start] - margins[propNames.end];\n      const spaceForEndAlignment = targetRect[noOverlap ? propNames.start : propNames.end] - margins[propNames.start];\n\n      const spaceForDefaultAlignment = defaultAlignStart ? spaceForStartAlignment : spaceForEndAlignment;\n      const spaceForOtherAlignment = defaultAlignStart ? spaceForEndAlignment : spaceForStartAlignment;\n\n      const shouldGoToDefaultSide =\n        spaceForDefaultAlignment > spaceForOtherAlignment || spaceForDefaultAlignment > contentSize;\n\n      return defaultAlignStart === shouldGoToDefaultSide;\n    }\n\n    /**\n     * Returns an adjusted value after resizing the browser window,\n     * to avoid wrong calculations when e.g. previously set `bottom`\n     * CSS property value is larger than the updated viewport height.\n     * See https://github.com/vaadin/web-components/issues/4604\n     */\n    __adjustBottomProperty(cssPropNameToSet, propNames, currentValue) {\n      let adjustedProp;\n\n      if (cssPropNameToSet === propNames.end) {\n        // Adjust horizontally\n        if (propNames.end === PROP_NAMES_VERTICAL.end) {\n          const viewportHeight = Math.min(window.innerHeight, document.documentElement.clientHeight);\n\n          if (currentValue > viewportHeight && this.__oldViewportHeight) {\n            const heightDiff = this.__oldViewportHeight - viewportHeight;\n            adjustedProp = currentValue - heightDiff;\n          }\n\n          this.__oldViewportHeight = viewportHeight;\n        }\n\n        // Adjust vertically\n        if (propNames.end === PROP_NAMES_HORIZONTAL.end) {\n          const viewportWidth = Math.min(window.innerWidth, document.documentElement.clientWidth);\n\n          if (currentValue > viewportWidth && this.__oldViewportWidth) {\n            const widthDiff = this.__oldViewportWidth - viewportWidth;\n            adjustedProp = currentValue - widthDiff;\n          }\n\n          this.__oldViewportWidth = viewportWidth;\n        }\n      }\n\n      return adjustedProp;\n    }\n\n    /**\n     * Returns an object with CSS position properties to set,\n     * e.g. { top: \"100px\" }\n     */\n    // eslint-disable-next-line max-params\n    __calculatePositionInOneDimension(targetRect, overlayRect, noOverlap, propNames, overlay, shouldAlignStart) {\n      const cssPropNameToSet = shouldAlignStart ? propNames.start : propNames.end;\n      const cssPropNameToClear = shouldAlignStart ? propNames.end : propNames.start;\n\n      const currentValue = parseFloat(overlay.style[cssPropNameToSet] || getComputedStyle(overlay)[cssPropNameToSet]);\n      const adjustedValue = this.__adjustBottomProperty(cssPropNameToSet, propNames, currentValue);\n\n      const diff =\n        overlayRect[shouldAlignStart ? propNames.start : propNames.end] -\n        targetRect[noOverlap === shouldAlignStart ? propNames.end : propNames.start];\n\n      const valueToSet = adjustedValue\n        ? `${adjustedValue}px`\n        : `${currentValue + diff * (shouldAlignStart ? -1 : 1)}px`;\n\n      return {\n        [cssPropNameToSet]: valueToSet,\n        [cssPropNameToClear]: '',\n      };\n    }\n  };\n"],
  "mappings": "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",
  "names": []
}
