import {
  PositionMixin
} from "./chunk-FEOKQDBU.js";
import {
  Overlay,
  overlay
} from "./chunk-6Z2FLVRD.js";
import {
  addValueToAttribute,
  removeValueFromAttribute
} from "./chunk-L55YM4J4.js";
import {
  generateUniqueId
} from "./chunk-26L5GZ27.js";
import {
  ElementMixin
} from "./chunk-35PYPRLR.js";
import {
  isKeyboardActive
} from "./chunk-OFT7WUTJ.js";
import {
  ThemePropertyMixin,
  registerStyles
} from "./chunk-VCK5WHZR.js";
import {
  css
} from "./chunk-KW5WBOXY.js";
import {
  PolymerElement
} from "./chunk-BK2NTPF4.js";
import {
  html
} from "./chunk-BPZOCPE6.js";

// node_modules/@vaadin/tooltip/theme/lumo/vaadin-tooltip-styles.js
var tooltipOverlay = css`
  :host {
    --vaadin-tooltip-offset-top: var(--lumo-space-xs);
    --vaadin-tooltip-offset-bottom: var(--lumo-space-xs);
    --vaadin-tooltip-offset-start: var(--lumo-space-xs);
    --vaadin-tooltip-offset-end: var(--lumo-space-xs);
  }

  [part='overlay'] {
    background: var(--lumo-base-color) linear-gradient(var(--lumo-contrast-5pct), var(--lumo-contrast-5pct));
    color: var(--lumo-body-text-color);
    font-size: var(--lumo-font-size-xs);
    line-height: var(--lumo-line-height-s);
  }

  [part='content'] {
    padding: var(--lumo-space-xs) var(--lumo-space-s);
  }
`;
registerStyles("vaadin-tooltip-overlay", [overlay, tooltipOverlay], { moduleId: "lumo-tooltip-overlay" });

// node_modules/@vaadin/tooltip/src/vaadin-tooltip-overlay.js
registerStyles(
  "vaadin-tooltip-overlay",
  css`
    [part='overlay'] {
      max-width: 40ch;
    }

    :host([position^='top'][top-aligned]) [part='overlay'],
    :host([position^='bottom'][top-aligned]) [part='overlay'] {
      margin-top: var(--vaadin-tooltip-offset-top, 0);
    }

    :host([position^='top'][bottom-aligned]) [part='overlay'],
    :host([position^='bottom'][bottom-aligned]) [part='overlay'] {
      margin-bottom: var(--vaadin-tooltip-offset-bottom, 0);
    }

    :host([position^='start'][start-aligned]) [part='overlay'],
    :host([position^='end'][start-aligned]) [part='overlay'] {
      margin-inline-start: var(--vaadin-tooltip-offset-start, 0);
    }

    :host([position^='start'][end-aligned]) [part='overlay'],
    :host([position^='end'][end-aligned]) [part='overlay'] {
      margin-inline-end: var(--vaadin-tooltip-offset-end, 0);
    }
  `,
  { moduleId: "vaadin-tooltip-overlay-styles" }
);
var memoizedTemplate;
var TooltipOverlay = class extends PositionMixin(Overlay) {
  static get is() {
    return "vaadin-tooltip-overlay";
  }
  static get template() {
    if (!memoizedTemplate) {
      memoizedTemplate = super.template.cloneNode(true);
      memoizedTemplate.content.querySelector('[part~="overlay"]').removeAttribute("tabindex");
      memoizedTemplate.content.querySelector('[part~="content"]').innerHTML = "<slot></slot>";
    }
    return memoizedTemplate;
  }
  static get properties() {
    return {
      position: {
        type: String,
        reflectToAttribute: true
      }
    };
  }
  ready() {
    super.ready();
    this.owner = this.__dataHost;
    this.owner._overlayElement = this;
  }
  requestContentUpdate() {
    super.requestContentUpdate();
    this.toggleAttribute("hidden", this.textContent.trim() === "");
    if (this.positionTarget && this.owner) {
      const style = getComputedStyle(this.owner);
      ["top", "bottom", "start", "end"].forEach((prop) => {
        this.style.setProperty(
          `--vaadin-tooltip-offset-${prop}`,
          style.getPropertyValue(`--vaadin-tooltip-offset-${prop}`)
        );
      });
    }
  }
  _updatePosition() {
    super._updatePosition();
    if (!this.positionTarget) {
      return;
    }
    if (this.position === "bottom" || this.position === "top") {
      const targetRect = this.positionTarget.getBoundingClientRect();
      const overlayRect = this.$.overlay.getBoundingClientRect();
      const offset = targetRect.width / 2 - overlayRect.width / 2;
      if (this.style.left) {
        const left = overlayRect.left + offset;
        if (left > 0) {
          this.style.left = `${left}px`;
        }
      }
      if (this.style.right) {
        const right = parseFloat(this.style.right) + offset;
        if (right > 0) {
          this.style.right = `${right}px`;
        }
      }
    }
    if (this.position === "start" || this.position === "end") {
      const targetRect = this.positionTarget.getBoundingClientRect();
      const overlayRect = this.$.overlay.getBoundingClientRect();
      const offset = targetRect.height / 2 - overlayRect.height / 2;
      this.style.top = `${overlayRect.top + offset}px`;
    }
  }
};
customElements.define(TooltipOverlay.is, TooltipOverlay);

// node_modules/@vaadin/tooltip/src/vaadin-tooltip.js
var DEFAULT_DELAY = 500;
var defaultFocusDelay = DEFAULT_DELAY;
var defaultHoverDelay = DEFAULT_DELAY;
var defaultHideDelay = DEFAULT_DELAY;
var closing = /* @__PURE__ */ new Set();
var warmedUp = false;
var warmUpTimeout = null;
var cooldownTimeout = null;
var TooltipStateController = class {
  constructor(host) {
    this.host = host;
  }
  open(options = { immediate: false }) {
    const { immediate, hover, focus } = options;
    const isHover = hover && this.hoverDelay > 0;
    const isFocus = focus && this.focusDelay > 0;
    if (!immediate && (isHover || isFocus) && !this.__closeTimeout) {
      this.__warmupTooltip(isFocus);
    } else {
      this.__showTooltip();
    }
  }
  close(immediate) {
    if (!immediate && this.hideDelay > 0) {
      this.__scheduleClose();
    } else {
      this.__abortClose();
      this._setOpened(false);
    }
    this.__abortWarmUp();
    if (warmedUp) {
      this.__abortCooldown();
      this.__scheduleCooldown();
    }
  }
  get openedProp() {
    return this.host.manual ? "opened" : "_autoOpened";
  }
  get focusDelay() {
    const tooltip = this.host;
    return tooltip.focusDelay != null && tooltip.focusDelay > 0 ? tooltip.focusDelay : defaultFocusDelay;
  }
  get hoverDelay() {
    const tooltip = this.host;
    return tooltip.hoverDelay != null && tooltip.hoverDelay > 0 ? tooltip.hoverDelay : defaultHoverDelay;
  }
  get hideDelay() {
    const tooltip = this.host;
    return tooltip.hideDelay != null && tooltip.hideDelay > 0 ? tooltip.hideDelay : defaultHideDelay;
  }
  _isOpened() {
    return this.host[this.openedProp];
  }
  _setOpened(opened) {
    this.host[this.openedProp] = opened;
  }
  __flushClosingTooltips() {
    closing.forEach((tooltip) => {
      tooltip._stateController.close(true);
      closing.delete(tooltip);
    });
  }
  __showTooltip() {
    this.__abortClose();
    this.__flushClosingTooltips();
    this._setOpened(true);
    warmedUp = true;
    this.__abortWarmUp();
    this.__abortCooldown();
  }
  __warmupTooltip(isFocus) {
    if (!this._isOpened()) {
      if (!warmedUp) {
        this.__scheduleWarmUp(isFocus);
      } else {
        this.__showTooltip();
      }
    }
  }
  __abortClose() {
    if (this.__closeTimeout) {
      clearTimeout(this.__closeTimeout);
      this.__closeTimeout = null;
    }
  }
  __abortCooldown() {
    if (cooldownTimeout) {
      clearTimeout(cooldownTimeout);
      cooldownTimeout = null;
    }
  }
  __abortWarmUp() {
    if (warmUpTimeout) {
      clearTimeout(warmUpTimeout);
      warmUpTimeout = null;
    }
  }
  __scheduleClose() {
    if (this._isOpened()) {
      closing.add(this.host);
      this.__closeTimeout = setTimeout(() => {
        closing.delete(this.host);
        this.__closeTimeout = null;
        this._setOpened(false);
      }, this.hideDelay);
    }
  }
  __scheduleCooldown() {
    cooldownTimeout = setTimeout(() => {
      cooldownTimeout = null;
      warmedUp = false;
    }, this.hideDelay);
  }
  __scheduleWarmUp(isFocus) {
    const delay = isFocus ? this.focusDelay : this.hoverDelay;
    warmUpTimeout = setTimeout(() => {
      warmUpTimeout = null;
      warmedUp = true;
      this.__showTooltip();
    }, delay);
  }
};
var Tooltip = class extends ThemePropertyMixin(ElementMixin(PolymerElement)) {
  static get is() {
    return "vaadin-tooltip";
  }
  static get template() {
    return html`
      <style>
        :host {
          display: none;
        }
      </style>
      <vaadin-tooltip-overlay
        id="[[_uniqueId]]"
        role="tooltip"
        renderer="[[_renderer]]"
        theme$="[[_theme]]"
        opened="[[__computeOpened(manual, opened, _autoOpened, _isConnected)]]"
        position-target="[[target]]"
        position="[[__effectivePosition]]"
        no-horizontal-overlap$="[[__computeNoHorizontalOverlap(__effectivePosition)]]"
        no-vertical-overlap$="[[__computeNoVerticalOverlap(__effectivePosition)]]"
        horizontal-align="[[__computeHorizontalAlign(__effectivePosition)]]"
        vertical-align="[[__computeVerticalAlign(__effectivePosition)]]"
        on-mouseleave="__onOverlayMouseLeave"
        modeless
      ></vaadin-tooltip-overlay>
    `;
  }
  static get properties() {
    return {
      context: {
        type: Object,
        value: () => {
          return {};
        }
      },
      focusDelay: {
        type: Number
      },
      for: {
        type: String,
        observer: "__forChanged"
      },
      hideDelay: {
        type: Number
      },
      hoverDelay: {
        type: Number
      },
      manual: {
        type: Boolean,
        value: false
      },
      opened: {
        type: Boolean,
        value: false
      },
      position: {
        type: String
      },
      shouldShow: {
        type: Object,
        value: () => {
          return (_target, _context) => true;
        }
      },
      target: {
        type: Object,
        observer: "__targetChanged"
      },
      text: {
        type: String,
        observer: "__textChanged"
      },
      generator: {
        type: Object
      },
      _autoOpened: {
        type: Boolean,
        observer: "__autoOpenedChanged"
      },
      _position: {
        type: String,
        value: "bottom"
      },
      __effectivePosition: {
        type: String,
        computed: "__computePosition(position, _position)"
      },
      _overlayElement: Object,
      __isTargetHidden: {
        type: Boolean,
        value: false
      },
      _isConnected: {
        type: Boolean
      }
    };
  }
  static get observers() {
    return ["__generatorChanged(_overlayElement, generator, context)"];
  }
  static setDefaultFocusDelay(focusDelay) {
    defaultFocusDelay = focusDelay != null && focusDelay >= 0 ? focusDelay : DEFAULT_DELAY;
  }
  static setDefaultHideDelay(hideDelay) {
    defaultHideDelay = hideDelay != null && hideDelay >= 0 ? hideDelay : DEFAULT_DELAY;
  }
  static setDefaultHoverDelay(hoverDelay) {
    defaultHoverDelay = hoverDelay != null && hoverDelay >= 0 ? hoverDelay : DEFAULT_DELAY;
  }
  constructor() {
    super();
    this._uniqueId = `vaadin-tooltip-${generateUniqueId()}`;
    this._renderer = this.__tooltipRenderer.bind(this);
    this.__onFocusin = this.__onFocusin.bind(this);
    this.__onFocusout = this.__onFocusout.bind(this);
    this.__onMouseDown = this.__onMouseDown.bind(this);
    this.__onMouseEnter = this.__onMouseEnter.bind(this);
    this.__onMouseLeave = this.__onMouseLeave.bind(this);
    this.__onKeyDown = this.__onKeyDown.bind(this);
    this.__onOverlayOpen = this.__onOverlayOpen.bind(this);
    this.__targetVisibilityObserver = new IntersectionObserver(
      ([entry]) => {
        this.__onTargetVisibilityChange(entry.isIntersecting);
      },
      { threshold: 1 }
    );
    this._stateController = new TooltipStateController(this);
  }
  connectedCallback() {
    super.connectedCallback();
    this._isConnected = true;
    document.body.addEventListener("vaadin-overlay-open", this.__onOverlayOpen);
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    if (this._autoOpened) {
      this._stateController.close(true);
    }
    this._isConnected = false;
    document.body.removeEventListener("vaadin-overlay-open", this.__onOverlayOpen);
  }
  __computeHorizontalAlign(position) {
    return ["top-end", "bottom-end", "start-top", "start", "start-bottom"].includes(position) ? "end" : "start";
  }
  __computeNoHorizontalOverlap(position) {
    return ["start-top", "start", "start-bottom", "end-top", "end", "end-bottom"].includes(position);
  }
  __computeNoVerticalOverlap(position) {
    return ["top-start", "top-end", "top", "bottom-start", "bottom", "bottom-end"].includes(position);
  }
  __computeVerticalAlign(position) {
    return ["top-start", "top-end", "top", "start-bottom", "end-bottom"].includes(position) ? "bottom" : "top";
  }
  __computeOpened(manual, opened, autoOpened, connected) {
    return connected && (manual ? opened : autoOpened);
  }
  __computePosition(position, defaultPosition) {
    return position || defaultPosition;
  }
  __tooltipRenderer(root) {
    root.textContent = typeof this.generator === "function" ? this.generator(this.context) : this.text;
  }
  __autoOpenedChanged(opened, oldOpened) {
    if (opened) {
      document.addEventListener("keydown", this.__onKeyDown, true);
    } else if (oldOpened) {
      document.removeEventListener("keydown", this.__onKeyDown, true);
    }
  }
  __forChanged(forId) {
    if (forId) {
      const target = this.getRootNode().getElementById(forId);
      if (target) {
        this.target = target;
      } else {
        console.warn(`No element with id="${forId}" found to show tooltip.`);
      }
    }
  }
  __targetChanged(target, oldTarget) {
    if (oldTarget) {
      oldTarget.removeEventListener("mouseenter", this.__onMouseEnter);
      oldTarget.removeEventListener("mouseleave", this.__onMouseLeave);
      oldTarget.removeEventListener("focusin", this.__onFocusin);
      oldTarget.removeEventListener("focusout", this.__onFocusout);
      oldTarget.removeEventListener("mousedown", this.__onMouseDown);
      this.__targetVisibilityObserver.unobserve(oldTarget);
      removeValueFromAttribute(oldTarget, "aria-describedby", this._uniqueId);
    }
    if (target) {
      target.addEventListener("mouseenter", this.__onMouseEnter);
      target.addEventListener("mouseleave", this.__onMouseLeave);
      target.addEventListener("focusin", this.__onFocusin);
      target.addEventListener("focusout", this.__onFocusout);
      target.addEventListener("mousedown", this.__onMouseDown);
      requestAnimationFrame(() => {
        this.__targetVisibilityObserver.observe(target);
      });
      addValueToAttribute(target, "aria-describedby", this._uniqueId);
    }
  }
  __onFocusin(event) {
    if (this.manual) {
      return;
    }
    if (!isKeyboardActive()) {
      return;
    }
    if (this.target.contains(event.relatedTarget)) {
      return;
    }
    if (!this.__isShouldShow()) {
      return;
    }
    this.__focusInside = true;
    if (!this.__isTargetHidden && (!this.__hoverInside || !this._autoOpened)) {
      this._stateController.open({ focus: true });
    }
  }
  __onFocusout(event) {
    if (this.manual) {
      return;
    }
    if (this.target.contains(event.relatedTarget)) {
      return;
    }
    this.__focusInside = false;
    if (!this.__hoverInside) {
      this._stateController.close(true);
    }
  }
  __onKeyDown(event) {
    if (event.key === "Escape") {
      event.stopPropagation();
      this._stateController.close(true);
    }
  }
  __onMouseDown() {
    this._stateController.close(true);
  }
  __onMouseEnter() {
    if (this.manual) {
      return;
    }
    if (!this.__isShouldShow()) {
      return;
    }
    if (this.__hoverInside) {
      return;
    }
    this.__hoverInside = true;
    if (!this.__isTargetHidden && (!this.__focusInside || !this._autoOpened)) {
      this._stateController.open({ hover: true });
    }
  }
  __onMouseLeave(event) {
    if (event.relatedTarget !== this._overlayElement) {
      this.__handleMouseLeave();
    }
  }
  __onOverlayMouseLeave(event) {
    if (event.relatedTarget !== this.target) {
      this.__handleMouseLeave();
    }
  }
  __handleMouseLeave() {
    if (this.manual) {
      return;
    }
    this.__hoverInside = false;
    if (!this.__focusInside) {
      this._stateController.close();
    }
  }
  __onOverlayOpen() {
    if (this.manual) {
      return;
    }
    if (this._overlayElement.opened && !this._overlayElement._last) {
      this._stateController.close(true);
    }
  }
  __onTargetVisibilityChange(isVisible) {
    const oldHidden = this.__isTargetHidden;
    this.__isTargetHidden = !isVisible;
    if (oldHidden && isVisible && (this.__focusInside || this.__hoverInside)) {
      this._stateController.open({ immediate: true });
      return;
    }
    if (!isVisible && this._autoOpened) {
      this._stateController.close(true);
    }
  }
  __isShouldShow() {
    if (typeof this.shouldShow === "function" && this.shouldShow(this.target, this.context) !== true) {
      return false;
    }
    return true;
  }
  __textChanged(text, oldText) {
    if (this._overlayElement && (text || oldText)) {
      this._overlayElement.requestContentUpdate();
    }
  }
  __generatorChanged(overlayElement, generator, context) {
    if (overlayElement) {
      if (generator !== this.__oldTextGenerator || context !== this.__oldContext) {
        overlayElement.requestContentUpdate();
      }
      this.__oldTextGenerator = generator;
      this.__oldContext = context;
    }
  }
};
customElements.define(Tooltip.is, Tooltip);

export {
  Tooltip
};
/**
 * @license
 * Copyright (c) 2022 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
//# sourceMappingURL=chunk-NXZXQAE7.js.map
